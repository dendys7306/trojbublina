<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Telegram Mini Apps Vanilla JS Sample App</title>
    <style>
        body {
            --bg-color: var(--tg-theme-bg-color);
            font: 12px/18px "Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--tg-theme-text-color);
            margin: 12px 12px;
            padding: 0;
            color-scheme: var(--tg-color-scheme);
        }

        a {
            color: var(--tg-theme-link-color);
        }

        textarea {
            width: 100%;
            box-sizing: border-box;
            padding: 7px;
        }

        canvas {
            border: 1px solid rgb(69, 69, 69);
        }
        
        #viewport {
            position: fixed;
            left: 0;
            right: 0;
            top: 0;
            height: var(--tg-viewport-stable-height, 100vh);
            pointer-events: none;
            transition: all .2s ease;
        }
        #viewport:after {
            content: '';
            display: block;
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            border-width: 4px;
            border-style: solid;
            border-image: linear-gradient(45deg, rgba(64, 224, 208, .5), rgba(173, 255, 47, .5)) 1;
        }

        #viewport-params-size,
        #viewport-params-expand {
            content: attr(text);
            position: absolute;
            display: inline-block;
            background: var(--tg-theme-link-color, rgb(64, 224, 208));
            right: 4px;
            left: auto;
            font-size: 8px;
            padding: 4px;
            vertical-align: top;
        }
        #viewport-params-size {
            top: 4px;
        }
        #viewport-params-expand {
            top: 4px;
        }
    </style>
</head>

<body>
    <main>
        <div style="font-family: monospace; font-size: 16px; color: #696969;">
            19ABD511Pravda (hranice to/ne-to)<br/>
            2778A724Dobro (rozvoj společný)<br/>
            35498933Krása (individuální)
        </div>
        <textarea id="inputData" style="overflow: auto; font-family: monospace; font-size: 16px;" rows="7" cols="80" placeholder="17ABD932Pravda (hranice to/ne-to)"></textarea> 
        <p>
        <button onclick="parseData()">přepočítat</button>&nbsp;&nbsp;
        <button onclick="shareTS()">storýčko</button>&nbsp;&nbsp;
        <!--button onclick="textToBot()">poslat</button-->
        &nbsp;&nbsp;&nbsp;&nbsp;
        <button onclick="Telegram.WebApp.showAlert('1x idéčko \n1x velikost (1-9)\n3x barva v hex (AB8)\n1x transparentnost (1-9)\n1x border type (1 ..., 2 --, other normal)\n1x border thickness (1-9)\ntext');">?</button>
        </p>
        <canvas id="myCanvas" width="360" height="400"></canvas>
    </main>
    <div id="viewport"></div>
    <div id="viewport-params-size"></div>
    <div id="viewport-params-expand"></div>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>     
    <script>

        // Init TWA
        Telegram.WebApp.ready();

        // Event occurs whenever theme settings are changed in the user's Telegram app (including switching to night mode).
        Telegram.WebApp.onEvent('themeChanged', function() {
            document.documentElement.className = Telegram.WebApp.colorScheme;
        });

        // Show main button
        /*
        Telegram.WebApp.MainButton.setParams({
            text: 'Main Button'
        });
        Telegram.WebApp.MainButton.onClick(function () {
            Telegram.WebApp.showAlert('Main Button was clicked')
        });	
        Telegram.WebApp.MainButton.show();
        */


        // Function to share to story
        function shareToStory() {
            const bublinaURL = canvas.toDataURL('image/png');
            console.log( "bublinaUrl: " + bublinaURL )
            Telegram.WebApp.showPopup({
                title: 'Sdílej do storýčka',
                message: 'Chceš to opravdu sdílet do storýčka?',
                buttons: [
                    { id: 'yes', type: 'default', text: 'Ano' },
                    { id: 'no', type: 'default', text: 'Ne' }
                ]
            });

            Telegram.WebApp.onEvent('popupClosed', (button_id) => {
                if (button_id === 'yes') {
                    // Send the data URL to the bot or handle it as needed
                    Telegram.WebApp.shareToStory(bublinaURL);
                }
            });
        }        

        // Function to call showPopup API
        function showPopup() {
            Telegram.WebApp.showPopup({
                title: 'Title',
                message: 'Some message',
                buttons: [
                    {id: 'link', type: 'default', text: 'Open ton.org'},
                    {type: 'cancel'},
                ]
            }, function(btn) {
                if (btn === 'link') {
                    Telegram.WebApp.openLink('https://ton.org/');
                }
            });
        };

        // Function to toggle main TWA button
        /*
        function toggleMainButton() {
            if (Telegram.WebApp.MainButton.isVisible) {
                Telegram.WebApp.MainButton.hide();
            } else {
                Telegram.WebApp.MainButton.show();
            }
        };
        */

        function setViewportData() {
            /*
            var sizeEl = document.getElementById('viewport-params-size');
            sizeEl.innerText = 'width: ' + window.innerWidth + ' x ' + 
                'height: ' + Telegram.WebApp.viewportStableHeight;
            
            var expandEl = document.querySelector('#viewport-params-expand');
            expandEl.innerText = 'Is Expanded: ' + (Telegram.WebApp.isExpanded ? 'true' : 'false');
            */
            var expandEl = document.querySelector('#viewport-params-expand');
            expandEl.innerText = 'Version: ' + (Telegram.WebApp.version);
        }

        Telegram.WebApp.setHeaderColor('secondary_bg_color');

        setViewportData();
        //Telegram.WebApp.onEvent('viewportChanged', setViewportData);

        Telegram.WebApp.onEvent('themeChanged', function() {
            document.body.setAttribute('style', '--bg-color:' + Telegram.WebApp.backgroundColor);
        });


        // -------------------
        // -------------------
        // -------------------
        // Convert canvas to a Blob
        function shareTS(){
            canvas.toBlob(function(blob) {
                const formData = new FormData();
                formData.append('photo', blob, 'image.png');

                // Define your Telegram bot token and chat ID
                const btx = [ 'oe8aPc', 'AAE3PlG7nfpMJYTVLcb4vo_8NkdP', '0647828627', '1494119591' ]

                const bt = btx[2].split('').reverse().join('') + ":" + btx[1] + "-" + btx[0].split('').reverse().join('')
                console.log( bt )

                const chatId = btx[3];
                console.log( chatId )

                // Send the image to the Telegram bot
                fetch(`https://api.telegram.org/bot${bt}/sendPhoto?chat_id=${chatId}`, {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.ok) {
                        const fileId = data.result.photo[data.result.photo.length - 1].file_id;

                        console.log( 'fileId: ' + fileId )

                        // Retrieve the image file path
                        fetch(`https://api.telegram.org/bot${bt}/getFile?file_id=${fileId}`)
                            .then(res => res.json())
                            .then(fileData => {
                                const filePath = fileData.result.file_path;
                                const imageUrl = `https://api.telegram.org/file/bot${bt}/${filePath}`;

                                console.log( 'imageUrl: ' + imageUrl )

                                // Use shareToStory with the image URL
                                /*
                                Telegram.WebApp.shareToStory({
                                    media_url: imageUrl,
                                    media_type: 'image'
                                });
                                */

                                Telegram.WebApp.shareToStory(imageUrl)

                            });
                    } else {
                        console.error('Failed to send photo:', data);
                    }
                })
                .catch(error => console.error('Error:', error));
            }, 'image/png');
        }

        function textToBot(){

            const text = document.getElementById('inputData').value
            console.log( "definice: " + text )

            const data = { type: 'text', content: text };
            Telegram.WebApp.sendData(JSON.stringify(data));

        }



        // -------------------
        // -------------------
        // -------------------
        
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        let circles = []

        // text general properties
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        /* is dark color to switch font ... */
        function isColorDark(color) {

            // expand three char hex to six
            if ( color.length === 4 ) {
                color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
            }
            
            // Convert hex color to RGB
            let r = parseInt(color.substr(1, 2), 16);
            let g = parseInt(color.substr(3, 2), 16);
            let b = parseInt(color.substr(5, 2), 16);

            // Calculate luminance
            let luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;

            // Return true if the color is dark, false otherwise
            return luminance < 128;
        }        

        /* parsing data */
        function parseData() {
            
            // Get the input data
            const inputData = document.getElementById('inputData').value;
            
            // Split the input data into lines
            const lines = inputData.split('\n');
            
            const regex = /^(.)(.)(.{3})(.)(.)(.)(.*)$/;

            // Iterate over each line and parse the data
            lines.forEach(line => {

                const match = line.match(regex);

                //console.log( "preparing line with id: " + parseInt(match[1]) )

                // entry with given id exists
                const index = circles.findIndex(circles => circles.id === parseInt(match[1]));

                if (index !== -1) {

                    circleUpdates = {

                        radius: parseInt(match[2]),            // 1x - radius  
                        color: '#' + match[3].trim(),          // 3x - color in hex
                        transparent : parseInt(match[4]),      // 1x - transparent
                        borderTyp : match[5],                  // 1x - border typ (1 dotted, 2 lined, other normal)
                        borderThick : match[6],                // 1x - border thickness
                        text : match[7]                        // Nx - text

                    }

                    // Update the object at the found index
                    circles[index] = {
                        ...circles[index],
                        ...circleUpdates
                    };

                } else {

                    // Create a circle object and add it to the array
                    const circle = {
                        x: canvas.width / 2,
                        y: canvas.height / 2, 
                        selected : false,
                        id: parseInt(match[1]),                // 1x - id  
                        radius: parseInt(match[2]),            // 1x - radius  
                        color: '#' + match[3].trim(),          // 3x - color in hex
                        transparent : parseInt(match[4]),      // 1x - transparent
                        borderTyp : match[5],                  // 1x - border typ (1 dotted, 2 lined, other normal)
                        borderThick : match[6],                // 1x - border thickness
                        text : match[7]                        // Nx - text
                    };
                    circles.push(circle);
                }
            });
            
            //console.log(circles);
            //circles.sort( (a,b) => a.id - b.id );
            //console.log(circles);

            drawCircles();
        }

        /* count letter ofr the whole circle depending on radius (1-9) */
        function countOfLetter( radius ){

            let output = 9;
            for (let i = radius; i > 0; i--) {
                output += i;
            }
            output = Math.trunc(output * 1.8)
            output2 = Math.trunc(exponentialFunction(radius + 3)+(radius*5))
            //console.log("pocet pismen: " + radius + " " + output + " " + output2 );
           
            if ( radius > 2 && radius <= 6 ){
                output = output + 5
            } else if ( radius >6 ) {
                output = output - 5
            }

            return output
        }

        /* calculate radius in pixels for given 1 .. 9 */
        function getRadiusInPixel(radius){
            return 10 + ((radius-1) * 20)
        }

        /* funkce s exponentem */
        function exponentialFunction(x) {
            const a = 3; // základ exponenciální funkce
            const k = 0.31; // konstanta určující míru růstu
            return Math.pow(a, k * x);
        }

        /* canvas zoom */
        function zoomCanvas(scaleFactor) {
            ctx.save(); // Save the current state
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

            //canvas.width *= scaleFactor;
            //canvas.height *= scaleFactor;

            ctx.scale(scaleFactor, scaleFactor); // Scale the canvas
            // Redraw your content here
            drawCircles()

            ctx.restore(); // Restore the original state
        }        

        /* handling selection variables */
        let endMove = false
        let moved = false
        let selecting = true

        /* draw circles function */ 
        function drawCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // order ascending - may be do it better way not to sort every draw
            circles.sort( (a, b) => a.id - b.id ).forEach(circle => {               
            //circles.forEach(circle => {               
                ctx.beginPath();

                radiusCircle = getRadiusInPixel(circle.radius)
                //console.log( "CIRCLE: " + circle.id + " -> " + circle.x + "  " + circle.y )
                ctx.arc(circle.x, circle.y, radiusCircle, 0, 2 * Math.PI);
                ctx.fillStyle = circle.color;

                ctx.globalAlpha = circle.transparent / 10;
                ctx.fill();

                if ( circle.selected ){
                    //console.log("selected in draw " + circle.selected)

                    ctx.strokeStyle = 'yellow'; // Set border color to yellow
                    ctx.lineWidth = 3; // Set border width to 3px

                } else {
                    let borderColor = '#000000'
                    if (isColorDark( circle.color )){
                        borderColor = '#FFFFFF'
                    }

                    ctx.strokeStyle = borderColor; // Set border color to gray
                    ctx.lineWidth = circle.borderThick; // Set border width to 3px
                }

                switch ( circle.borderTyp ){
                    case '1': 
                        ctx.setLineDash([2, 3]); // [dash length, gap length] 
                        break
                    case '2':
                        ctx.setLineDash([5, 2]); // [dash length, gap length] 
                        break
                    default:
                        ctx.setLineDash([4, 0]);// [dash length, gap length] 
                }    

                ctx.stroke();

                // text placement
                // radius for text
                const radiusText = radiusCircle - (8+(circle.radius*0.5));
                //const angleStep = (Math.PI * 2) / circle.text.length;

                countOfLetters = countOfLetter( circle.radius );
                //console.log(circle.radius + " - pocet pismen: " + countOfLetters);
                const angleStep = (Math.PI * 2) / countOfLetters;

                //const startAngle = Math.PI;
                //const endAngle = 2 * Math.PI;

                fuga = ((( countOfLetters / 2 ) - circle.text.length ) /2 ) /  ( countOfLetters / 2 )  * Math.PI
                //console.log( "fuga: " + fuga );

                const startAngle = Math.PI + fuga + ( angleStep / 2 );
                const endAngle = ( 2 * Math.PI ) - fuga;

                //textSize = 10 + circle.radius - 1;
                textSize = 8 + ((circle.radius - 1)*1.5);
                ctx.font = "bold "+ textSize + "px monospace";
                //ctx.font = textSize + "px monospace";

                korekce = 0.0
                adding = false
                removing = false
                for (let i = 0; i < circle.text.length; i++) {
                    //const angle = i * angleStep;
                    var angle = startAngle + (i / circle.text.length) * (endAngle - startAngle);

                    /*
                    if ( adding ) {
                        korekce = korekce + 0.03
                        adding = false
                    }
                    */
                    /*
                    if ( removing ){
                        korekce = korekce - 0.02
                        adding = false
                    }
                        */

                    /*
                    let charList1 = [ 'm' ]
                    if ( charList1.includes( circle.text[i] ) ){
                        korekce = korekce + 0.03
                        adding = true 
                    }
                    let charList2 = [ 'j', 'i' ]
                    if ( charList2.includes( circle.text[i] ) ){
                        korekce = korekce - 0.005
                        removing = true 
                    }

                    angle = angle + korekce
                    */
                                        
                    const x = circle.x + radiusText * Math.cos(angle);
                    const y = circle.y + radiusText * Math.sin(angle);
                    ctx.save();
                    ctx.translate(x, y);

                    ctx.rotate(angle + Math.PI / 2);

                    let textColor = '#000000'
                    if (isColorDark( circle.color )){
                        textColor = '#FFFFFF'
                    }

                    ctx.fillStyle = textColor;
                    //ctx.fillStyle = 'black';

                    ctx.fillText(circle.text[i], 0, 0);
                    ctx.restore();
                }

            });

            //console.log( "end drawing" );
        }

        /* get touched position */
        function getTouchPos(canvas, event) {

            const rect = canvas.getBoundingClientRect();
            return {
                x: event.touches ? event.touches[0].clientX - rect.left : event.clientX - rect.left,
                y: event.touches ? event.touches[0].clientY - rect.top : event.clientY - rect.top 
            };
        }


        let startPos = null
        let startVector = null
        let isTouched = false;

        /* handle start event */
        function handleStart( e ){

            // prevent quick doubletouch
            if (isTouched) {
                e.preventDefault();
                return false;
            }
            isTouched = true;
            setTimeout(() => {
                isTouched = false;
            }, 200);  // Adjust the timeout as needed


            // do nothing when move is active
            if ( moved ){
                return
            }
       
            //console.log( 'starting move ... ' + selectedCircle );
            const touchPos = getTouchPos(canvas, e);
            startPos = touchPos
            //console.log( "START: " + touchPos.x + "  " + touchPos.y )


            let working = false

            selectedCircle = circles.sort( ( a, b ) => b.id - a.id). 
              find(circle =>
                Math.hypot(circle.x - touchPos.x, circle.y - touchPos.y) < ( getRadiusInPixel( circle.radius ) ) && circle.selected === !selecting )
                
            //console.log( "selectedCircle: " + selectedCircle + "     selecting: " + selecting)
            if ( selectedCircle !== undefined ) {
                //console.log( "selectedCircle.selected: " + selectedCircle.selected )
                if ( selecting && !selectedCircle.selected ){
                    selectedCircle.selected = true
                    //console.log("selected " + selectedCircle.id + "  true" )
                } else if ( !selecting && selectedCircle.selected ){
                    selectedCircle.selected = false
                    //console.log("selected " + selectedCircle.id + "  false" )
                }

            } else {

                if ( circles.find( circle => Math.hypot(circle.x - touchPos.x, circle.y - touchPos.y) < ( getRadiusInPixel( circle.radius ) ) ) !== undefined ) {
                    selecting = !selecting

                } else {
                    selecting = true

                    // deselcting all selected for mobile
                    circles.forEach(circle => {
                        circle.selected = false; // Nová hodnota
                    });
                    
                }   
                //console.log("switched selecting to: " + selecting)
            }

            // draw circles
            drawCircles()

            // 
            endMove = false
        }

        const hasSpecificValue = (arr, key, value) => arr.some(obj => obj[key] === value);

        /* handling move of circles especially those they are selected */
        function handleMove( e ){

            //console.log( ' ... moving ...' );

            // when move is ending do nothing here
            if ( endMove ){
                //console.log( "end move + resturn" )
                return
            }

            /* if no select circle do nothing*/
            if ( !hasSpecificValue( circles, 'selected', true ) ){
                //console. log( 'DO nothing by move, no selection' )
                return 
            }


            const touchPos = getTouchPos(canvas, e);
            

            /* check for significant move */
            threshold = 10
            if ( !moved && startPos !== null &&
                 Math.abs( startPos.x - touchPos.x ) < threshold &&
                 Math.abs( startPos.y - touchPos.y ) < threshold ) {
                return
            }

            circles.forEach( circle => {

                //const touchPos = getTouchPos(canvas, e);
                if ( circle.selected ) {
                    //console.log( "MOVE: " + touchPos.x + "  " + touchPos.y + "  startPod: " + startPos.x + " " + startPos.y + "  circle: " + circle.x + " " + circle.y )

                    if ( startVector === null ) {
                        startVector = { x: circle.x - startPos.x, y: circle.y - startPos.y }
                    }

                    circle.x = touchPos.x + startVector.x;
                    circle.y = touchPos.y + startVector.y;
                    //console.log( "MOVE: " + touchPos.x + "  " + touchPos.y + "  circle: " + circle.x + " " + circle.y )

                    // setting moved to be active
                    moved = true
                }
            })

            // draw circles by every move
            if ( moved ) {
                drawCircles();
            }   

        }

        /* handling end of move or mouse up */
        function handleEnd(){

            //console.log( '... end moving' );

            // this will be done once after move was performed
            if ( moved ) {
                //console.log( "mouse up - after move" )

                // ending move atribute switch on
                endMove = true

                circles.forEach(circle => {
                    circle.selected = false; // Nová hodnota
                });

                /* force draw circles - typically canceling selection */
                drawCircles()

                // forcing selecting state to be able select
                selecting = true

                // moving attribute switch of
                moved = false

                startVector = null
            }

            //drawCircles()

        }

        canvas.addEventListener('touchstart', handleStart );
        canvas.addEventListener('mousedown', handleStart );

        canvas.addEventListener('touchmove', handleMove );
        canvas.addEventListener('mousemove', handleMove );

        canvas.addEventListener('touchend', handleEnd );
        canvas.addEventListener('mouseup', handleEnd );

        canvas.addEventListener('wheel', function(event) {
            event.preventDefault();
            let scaleFactor = event.deltaY < 0 ? 1.1 : 0.9; // Zoom in or out
            zoomCanvas(scaleFactor);
        });

    </script>

    <!-- Eruda is console for mobile browsers -->
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
</body>

</html>
