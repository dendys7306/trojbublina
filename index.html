<!DOCTYPE html>
<html lang="en">

<head>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Touch Move</title>
    <style>
        canvas {
            border: 1px solid rgb(69, 69, 69);
        }
    </style>

</head>

<body>
    <div style="font-family: monospace; font-size: 16px; color: #696969;">
        19ABD511Pravda (hranice to/ne-to)<br/>
        2778A724Dobro (rozvoj společný)<br/>
        35498933Krása (individuální)
    </div>
    
    <textarea id="inputData" style="width: 360px; height: 150px; overflow: auto; font-family: monospace; font-size: 16px;" rows="7" cols="80" placeholder="17ABD932Pravda (hranice to/ne-to)"></textarea> 
    <button onclick="parseData()">přepočítat</button>
    <button onclick="alert('1x idéčko \n1x velikost (1-9)\n3x barva v hex (AB8)\n1x transparentnost (1-9)\n1x border type (1 ..., 2 --, other normal)\n1x border thickness (1-9)\ntext');">popis</button>
    <canvas id="myCanvas" width="360" height="400"></canvas>
    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        let circles = []

        // todo multiple selection this mark should be in the array
        let selectedCircle = null;

        // Add text around the circle
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        /* parsing data */
        function parseData() {
            // Get the input data
            const inputData = document.getElementById('inputData').value;
            
            // Split the input data into lines
            const lines = inputData.split('\n');
            
            const regex = /^(.)(.)(.{3})(.)(.)(.)(.*)$/;

            // Iterate over each line and parse the data
            lines.forEach(line => {

                const match = line.match(regex);

                /* if id exists */
                const index = circles.findIndex(circles => circles.id === match[1]);

                if (index !== -1) {

                    circleUpdates = {

                        radius: parseInt(match[2]),            // 1x - radius  
                        color: '#' + match[3].trim(),          // 3x - color in hex
                        transparent : parseInt(match[4]),      // 1x - transparent
                        borderTyp : match[5],                  // 1x - border typ (1 dotted, 2 lined, other normal)
                        borderThick : match[6],                // 1x - border thickness
                        text : match[7]                        // Nx - text

                    }

                    // Update the object at the found index
                    circles[index] = {
                        ...circles[index],
                        ...circleUpdates
                    };

                } else {

                    // Create a circle object and add it to the array
                    const circle = {
                        x: canvas.width / 2,
                        y: canvas.height / 2, 
                        id: match[1].trim(),                   // 1x - id  
                        radius: parseInt(match[2]),            // 1x - radius  
                        color: '#' + match[3].trim(),          // 3x - color in hex
                        transparent : parseInt(match[4]),      // 1x - transparent
                        borderTyp : match[5],                  // 1x - border typ (1 dotted, 2 lined, other normal)
                        borderThick : match[6],                // 1x - border thickness
                        text : match[7]                        // Nx - text
                    };
                    circles.push(circle);
                }
            });
            
            // Log the array of circles to the console
            //console.log(circles);

            drawCircles();
        }

        /* handling canvas */
        function countOfLetter( radius ){

            let output = 9;
            for (let i = radius; i > 0; i--) {
                output += i;
            }
            output = Math.trunc(output * 1.8)
            output2 = Math.trunc(exponentialFunction(radius + 3)+(radius*5))
            //console.log("pocet pismen: " + radius + " " + output + " " + output2 );
           
            if ( radius > 2 && radius <= 6 ){
                output = output + 5
            } else if ( radius >6 ) {
                output = output - 5
            }

            return output
        }

        function getRadiusInPixel(radius){
            return 10 + ((radius-1) * 20)
        }

        function exponentialFunction(x) {
            const a = 3; // základ exponenciální funkce
            const k = 0.31; // konstanta určující míru růstu
            return Math.pow(a, k * x);
        }


        let lastSelectedIndex = 0
        let endMove = false

        function drawCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            circles.sort( (a, b) => a.id - b.id ).forEach(circle => {               
                ctx.beginPath();

                radiusCircle = getRadiusInPixel(circle.radius)
                ctx.arc(circle.x, circle.y, radiusCircle, 0, 2 * Math.PI);
                ctx.fillStyle = circle.color;

                ctx.globalAlpha = circle.transparent / 10;
                ctx.fill();

                if ( selectedCircle === circle ){
                    //console.log("selected " + selectedCircle)

                    ctx.strokeStyle = 'yellow'; // Set border color to yellow
                    ctx.lineWidth = 3; // Set border width to 3px

                } else {
                    ctx.strokeStyle = '#333333'; // Set border color to gray
                    ctx.lineWidth = circle.borderThick; // Set border width to 3px
                }

                switch ( circle.borderTyp ){
                    case '1': 
                        ctx.setLineDash([2, 3]); // [dash length, gap length] 
                        break
                    case '2':
                        ctx.setLineDash([5, 2]); // [dash length, gap length] 
                        break
                    default:
                        ctx.setLineDash([4, 0]);// [dash length, gap length] 
                }    

                ctx.stroke();

                // text placement
                // radius for text
                const radiusText = radiusCircle - (8+(circle.radius*0.5));
                //const angleStep = (Math.PI * 2) / circle.text.length;

                countOfLetters = countOfLetter( circle.radius );
                //console.log(circle.radius + " - pocet pismen: " + countOfLetters);
                const angleStep = (Math.PI * 2) / countOfLetters;

                //const startAngle = Math.PI;
                //const endAngle = 2 * Math.PI;

                fuga = ((( countOfLetters / 2 ) - circle.text.length ) /2 ) /  ( countOfLetters / 2 )  * Math.PI

                //console.log( "fuga: " + fuga );

                const startAngle = Math.PI + fuga + ( angleStep / 2 );
                const endAngle = ( 2 * Math.PI ) - fuga;

                //textSize = 10 + circle.radius - 1;
                textSize = 8 + ((circle.radius - 1)*1.5);
                ctx.font = "bold "+ textSize + "px Times";

                for (let i = 0; i < circle.text.length; i++) {
                    //const angle = i * angleStep;
                    var angle = startAngle + (i / circle.text.length) * (endAngle - startAngle);

                    const x = circle.x + radiusText * Math.cos(angle);
                    const y = circle.y + radiusText * Math.sin(angle);
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle + Math.PI / 2);
                    ctx.fillStyle = 'black';
                    ctx.fillText(circle.text[i], 0, 0);
                    ctx.restore();
                }

            });

            //console.log( "end drawing" );
        }

        function getTouchPos(canvas, event) {

            const rect = canvas.getBoundingClientRect();
            return {
                x: event.touches ? event.touches[0].clientX - rect.left : event.clientX - rect.left,
                y: event.touches ? event.touches[0].clientY - rect.top : event.clientY - rect.top 
            };
        }


        let runStart = 0

        function handleStart( e ){
            
            //console.log( 'starting move ... ' + selectedCircle );
            const touchPos = getTouchPos(canvas, e);
            
            let previousSelected = selectedCircle   
            selectedCircle = circles.filter( (circle, index) => selectedCircle != circle && index >= lastSelectedIndex ).find(circle =>
                Math.hypot(circle.x - touchPos.x, circle.y - touchPos.y) < ( getRadiusInPixel( circle.radius ) )                            
            );

            if ( selectedCircle === undefined ){

                selectedCircle = circles.find(circle =>
                Math.hypot(circle.x - touchPos.x, circle.y - touchPos.y) < ( getRadiusInPixel( circle.radius ) )                            
            );} 

            //console.log( 'starting move TO_MOVE ... ' + selectedCircle );
            endMove = false
            if ( selectedCircle ) {
                lastSelectedIndex = circles.indexOf( selectedCircle )
                if ( lastSelectedIndex == circles.length - 1){
                    lastSelectedIndex = 0
                }
                //console.log( '  last selected index: ' + lastSelectedIndex );
            }
            drawCircles()
        }

        function handleMove( e ){

            //console.log( ' ... moving ...' );
            if (selectedCircle && !endMove) {
                const touchPos = getTouchPos(canvas, e);
                selectedCircle.x = touchPos.x;
                selectedCircle.y = touchPos.y;
                drawCircles();
            }

        }

        function handleEnd(){

            //console.log( '... end moving' );

            endMove = true
            //selectedCircle = null;

            //drawCircles()
        }

        canvas.addEventListener('touchstart', handleStart );
        canvas.addEventListener('mousedown', handleStart );

        canvas.addEventListener('touchmove', handleMove );
        canvas.addEventListener('mousemove', handleMove );

        canvas.addEventListener('touchend', handleEnd );
        canvas.addEventListener('mouseup', handleEnd );

    </script>
</body>

</html>
