<!DOCTYPE html>
<html lang="en">

<head>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Touch Move</title>
    <style>
        canvas {
            border: 1px solid rgb(69, 69, 69);
        }
    </style>

</head>

<body>
    <div style="font-family: 'Courier New', Courier, monospace; font-size: 12px; color: #696969;">
        19ABD511Pravda (hranice to/ne-to)<br/>
        2778A724Dobro (rozvoj společný)<br/>
        35498933Krása (individuální)
    </div>
    
    <textarea id="inputData" style="width: 360px; height: 150px; overflow: auto;" rows="7" cols="80" placeholder="17ABD932Pravda (hranice to/ne-to)"></textarea> 
    <button onclick="parseData()">přepočítat</button>
    <button onclick="alert('1x idéčko \n1x velikost (3,5,7,9)\n3x barva v hex (AB8)\n1x transparentnost (1-9)\n...');">popis</button>
    <canvas id="myCanvas" width="360" height="400"></canvas>
    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        let circles = []

        // todo multiple selection this mark should be in the array
        let selectedCircle = null;

        // Add text around the circle
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        /*
        const radius = 89;
        const angleStep = (Math.PI * 2) / text.length;
        const startAngle = Math.PI;
        const endAngle = 2 * Math.PI;

        for (let i = 0; i < text.length; i++) {
            //const angle = i * angleStep;
            const angle = startAngle + (i / text.length) * (endAngle - startAngle);
            const x = 200 + radius * Math.cos(angle);
            const y = 200 + radius * Math.sin(angle);
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle + Math.PI / 2);
            ctx.fillText(text[i], 0, 0);
            ctx.restore();
        }
        */

        const order = [ 3, 5, 7, 9 ]

        /* parsing data */
        function parseData() {
            // Get the input data
            const inputData = document.getElementById('inputData').value;
            
            // Split the input data into lines
            const lines = inputData.split('\n');
            
            const regex = /^(.)(.)(.{3})(.)(.)(.)(.*)$/;

            // Iterate over each line and parse the data
            lines.forEach(line => {

                const match = line.match(regex);

                /* if id exists */
                const index = circles.findIndex(circles => circles.id === match[1]);

                if (index !== -1) {

                    circleUpdates = {

                        radius: parseInt(match[2]),            // 1x - radius  
                        color: '#' + match[3].trim(),          // 3x - color in hex
                        transparent : parseInt(match[4]),      // 1x - transparent
                        borderTyp : match[5],                  // 1x - border typ (1 dotted, 2 lined, other normal)
                        borderThick : match[6],                // 1x - border thickness
                        text : match[7]                        // Nx - text

                    }

                    // Update the object at the found index
                    circles[index] = {
                        ...circles[index],
                        ...circleUpdates
                    };

                } else {

                    // Create a circle object and add it to the array
                    const circle = {
                        x: 100,
                        y: 100, 
                        id: match[1].trim(),                   // 1x - id  
                        radius: parseInt(match[2]),            // 1x - radius  
                        color: '#' + match[3].trim(),          // 3x - color in hex
                        transparent : parseInt(match[4]),      // 1x - transparent
                        borderTyp : match[5],                  // 1x - border typ (1 dotted, 2 lined, other normal)
                        borderThick : match[6],                // 1x - border thickness
                        text : match[7]                        // Nx - text
                    };
                    circles.push(circle);
                }
            });
            
            // Log the array of circles to the console
            //console.log(circles);

            drawCircles();
        }

        /* handling canvas */
        function countOfLetter( radius ){

            result = 7;


            for ( i = 0; order[i] <= radius; i++ ) {

                result = result + order[i];             

            }
            
            return ( result * 2 )
        }

        let lastSelectedIndex = 0
        let endMove = false

        function drawCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            circles.forEach(circle => {               
                ctx.beginPath();

                // 3,5,7,9 are available values
                // radius for circle
                radiusCircle = circle.radius * 10;
                ctx.arc(circle.x, circle.y, radiusCircle, 0, 2 * Math.PI);
                ctx.fillStyle = circle.color;

                ctx.globalAlpha = circle.transparent / 10;
                ctx.fill();

                if ( selectedCircle === circle ){
                    //console.log("selected " + selectedCircle)

                    ctx.strokeStyle = 'yellow'; // Set border color to yellow
                    ctx.lineWidth = 3; // Set border width to 3px

                } else {
                    ctx.strokeStyle = '#333333'; // Set border color to gray
                    ctx.lineWidth = circle.borderThick; // Set border width to 3px
                }

                switch ( circle.borderTyp ){
                    case '1': 
                        ctx.setLineDash([2, 3]); // [dash length, gap length] 
                        break
                    case '2':
                        ctx.setLineDash([5, 2]); // [dash length, gap length] 
                        break
                    default:
                        ctx.setLineDash([4, 0]);// [dash length, gap length] 
                }    

                ctx.stroke();

                // text placement
                // radius for text
                const radiusText = radiusCircle - 10;
                //const angleStep = (Math.PI * 2) / circle.text.length;

                countOfLetters = countOfLetter( circle.radius );
                //console.log(circle.radius + " - pocet pismen: " + countOfLetters);
                const angleStep = (Math.PI * 2) / countOfLetters;

                //const startAngle = Math.PI;
                //const endAngle = 2 * Math.PI;

                fuga = ((( countOfLetters / 2 ) - circle.text.length ) /2 ) /  ( countOfLetters / 2 )  * Math.PI

                //console.log( "fuga: " + fuga );

                const startAngle = Math.PI + fuga + ( angleStep / 2 );
                const endAngle = ( 2 * Math.PI ) - fuga;

                textSize = 10 + circle.radius - 1;
                ctx.font = textSize + "px Times bold";

                for (let i = 0; i < circle.text.length; i++) {
                    //const angle = i * angleStep;
                    var angle = startAngle + (i / circle.text.length) * (endAngle - startAngle);
                    let charList1 = [ 'D', 'K' ]
                    if ( charList1.includes( circle.text[i] ) ){
                        angle = angle - 0.03 
                    }
                    /*
                    let charList2 = [ 'i', 'j' ]
                    if ( charList2.includes(circle.text[i])  ){
                        angle = angle + 0.02 
                    }
                    */
                    const x = circle.x + radiusText * Math.cos(angle);
                    const y = circle.y + radiusText * Math.sin(angle);
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle + Math.PI / 2);
                    ctx.fillStyle = 'black';
                    ctx.fillText(circle.text[i], 0, 0);
                    ctx.restore();
                }

            });

            //console.log( "end drawing" );
        }

        function getTouchPos(canvas, event) {

            const rect = canvas.getBoundingClientRect();
            return {
                x: event.touches ? event.touches[0].clientX - rect.left : event.clientX - rect.left,
                y: event.touches ? event.touches[0].clientY - rect.top : event.clientY - rect.top 
            };
        }


        let runStart = 0

        function handleStart( e ){
            
            //console.log( 'starting move ... ' + selectedCircle );
            const touchPos = getTouchPos(canvas, e);
            
            /*
            circles.forEach( (circle) => {
                if ( circle === selectedCircle ){
                    console.log( "circle selected match" )
                } else {
                    console.log( " NOT circle selected match" )
                }
             })
            */

            let previousSelected = selectedCircle   
            selectedCircle = circles.filter( (circle, index) => selectedCircle != circle && index >= lastSelectedIndex ).find(circle =>
                Math.hypot(circle.x - touchPos.x, circle.y - touchPos.y) < ( circle.radius * 10 )                            
            );


            if ( selectedCircle === undefined ){

                selectedCircle = circles.find(circle =>
                Math.hypot(circle.x - touchPos.x, circle.y - touchPos.y) < ( circle.radius * 10 )                            
            );} 

            //console.log( 'starting move TO_MOVE ... ' + selectedCircle );
            endMove = false
            if ( selectedCircle ) {
                lastSelectedIndex = circles.indexOf( selectedCircle )
                if ( lastSelectedIndex == circles.length - 1){
                    lastSelectedIndex = 0
                }
                //console.log( '  last selected index: ' + lastSelectedIndex );
            }
            drawCircles()
        }

        function handleMove( e ){

            //console.log( ' ... moving ...' );
            if (selectedCircle && !endMove) {
                const touchPos = getTouchPos(canvas, e);
                selectedCircle.x = touchPos.x;
                selectedCircle.y = touchPos.y;
                drawCircles();
            }

        }

        function handleEnd(){

            //console.log( '... end moving' );

            endMove = true
            //selectedCircle = null;


            //drawCircles()


        }

        canvas.addEventListener('touchstart', handleStart );
        canvas.addEventListener('mousedown', handleStart );

        canvas.addEventListener('touchmove', handleMove );
        canvas.addEventListener('mousemove', handleMove );

        canvas.addEventListener('touchend', handleEnd );
        canvas.addEventListener('mouseup', handleEnd );

/*
        canvas.addEventListener('touchstart', (e) => {
            const touchPos = getTouchPos(canvas, e);
            selectedCircle = circles.find(circle =>
                Math.hypot(circle.x - touchPos.x, circle.y - touchPos.y) < circle.radius
            );
        });

        canvas.addEventListener('touchmove', (e) => {
            if (selectedCircle) {
                const touchPos = getTouchPos(canvas, e);
                selectedCircle.x = touchPos.x;
                selectedCircle.y = touchPos.y;
                drawCircles();
            }
        });

        canvas.addEventListener('touchend', () => {
            selectedCircle = null;
        });
*/

        //drawCircles();

    </script>
</body>

</html>
