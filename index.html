<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Telegram Mini Apps Vanilla JS Sample App</title>
    <style>
        body {
            --bg-color: var(--tg-theme-bg-color);
            font: 12px/18px "Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--tg-theme-text-color);
            margin: 12px 12px;
            padding: 0;
            color-scheme: var(--tg-color-scheme);
        }

        a {
            color: var(--tg-theme-link-color);
        }

        textarea {
            width: 100%;
            box-sizing: border-box;
            padding: 7px;
        }

        canvas {
            border: 1px solid rgb(69, 69, 69);
        }
        
        #viewport {
            position: fixed;
            left: 0;
            right: 0;
            top: 0;
            height: var(--tg-viewport-stable-height, 100vh);
            pointer-events: none;
            transition: all .2s ease;
        }
        #viewport:after {
            content: '';
            display: block;
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            border-width: 4px;
            border-style: solid;
            border-image: linear-gradient(45deg, rgba(64, 224, 208, .5), rgba(173, 255, 47, .5)) 1;
        }

        #viewport-params-size,
        #viewport-params-expand {
            content: attr(text);
            position: absolute;
            display: inline-block;
            background: var(--tg-theme-link-color, rgb(64, 224, 208));
            right: 4px;
            left: auto;
            font-size: 8px;
            padding: 4px;
            vertical-align: top;
        }
        #viewport-params-size {
            top: 4px;
        }
        #viewport-params-expand {
            top: 4px;
        }


        .dynamic-button {
            width: 32px;
            height: 32px;
            /*background-color: lightblue;*/
            margin: 2px;
            border: none;
            cursor: pointer;
        }

        /* Basic styles for your link */
        .dynamic-link {
            /*display: block;*/
            margin: 5px 0;
            color: blue;
            text-decoration: underline;
            font-size: medium;
            padding-left: 3px;
            padding-right: 3px;
        }

        .slot-div {
            width: auto;                /* Set the width of the div */
            height: auto;                /* Allow the height to adjust based on content */
            word-wrap: break-word;       /* This ensures long words break to the next line if necessary */
            overflow-wrap: break-word;   /* Alternative property for better compatibility */
            border: 1px solid rgb(60, 119, 247);      /* Optional: border for visibility */
            padding: 5px;               /* Optional: padding for spacing */
           /* background-color: rgba(224, 247, 255, 0.795);*/ /* Optional: background color for visibility */
        }     
        
        .selected {
            background-color: hsl(216, 100%, 59%);
            color: white;
        }
    </style>
</head>

<body>
    <main>
        <textarea id="inputData" style="overflow: auto; font-family: monospace; font-size: 16px;" rows="7" cols="80" placeholder="17ABD932Pravda (hranice to/ne-to)"></textarea> 
        <p>
        <button onclick="parseData()">display</button>&nbsp;&nbsp;
        <button onclick="shareTS()">story</button>&nbsp;&nbsp;
        <button id="createSlot">slot</button>&nbsp;&nbsp;
        <button id="export" onclick='saveToCloud()'>EXP</button>&nbsp;&nbsp;
        <button id="import" onclick='loadFromCloud()'>IMP</button>&nbsp;&nbsp;
        <input type="file" id="fileInput" accept=".json" style="display: none;">
        <button onclick="document.getElementById('fileInput').click()">FILE</button>&nbsp;&nbsp;
        <!--button onclick="textToBot()">poslat</button-->
        <button onclick="Telegram.WebApp.showAlert('1x idéčko \n1x velikost (1-9)\n3x barva v hex (AB8)\n1x transparentnost (1-9)\n1x border type (1 ..., 2 --, other normal)\n1x border thickness (1-9)\ntext');">?</button>
        <!--br/><a href="javascript:;" onclick="return requestWriteAccess(this);">Request write access</a-->
        </p>
        <canvas id="myCanvas" width="360" height="400"></canvas>

        <div id="slotContainer" class="slot-div"></div>
    </main>
    <div id="viewport"></div>
    <div id="viewport-params-size"></div>
    <div id="viewport-params-expand"></div>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>     
    <script>

        // Init TWA
        Telegram.WebApp.ready();

        function requestWriteAccess(el) {
            if ( Telegram.WebApp.version > 7 ){
                Telegram.WebApp.requestWriteAccess(function(allowed) {
                    if (allowed) {
                        el.nextElementSibling.innerHTML = '(Access granted)'
                        //el.nextElementSibling.className = 'ok'
                    } else {
                        el.nextElementSibling.innerHTML = '(User declined this request)'
                        //el.nextElementSibling.className = 'err'
                    }
                })
            }
        }

        // Event occurs whenever theme settings are changed in the user's Telegram app (including switching to night mode).
        Telegram.WebApp.onEvent('themeChanged', function() {
            document.documentElement.className = Telegram.WebApp.colorScheme;
        });

        // Show main button
        /*
        Telegram.WebApp.MainButton.setParams({
            text: 'Main Button'
        });
        Telegram.WebApp.MainButton.onClick(function () {
            Telegram.WebApp.showAlert('Main Button was clicked')
        });	
        Telegram.WebApp.MainButton.show();
        */


        // Function to share to story
        function shareToStory() {
            const bublinaURL = canvas.toDataURL('image/png');
            console.log( "bublinaUrl: " + bublinaURL )
            Telegram.WebApp.showPopup({
                title: 'Sdílej do storýčka',
                message: 'Chceš to opravdu sdílet do storýčka?',
                buttons: [
                    { id: 'yes', type: 'default', text: 'Ano' },
                    { id: 'no', type: 'default', text: 'Ne' }
                ]
            });

            Telegram.WebApp.onEvent('popupClosed', (button_id) => {
                if (button_id === 'yes') {
                    // Send the data URL to the bot or handle it as needed
                    Telegram.WebApp.shareToStory(bublinaURL);
                }
            });
        }        

        // Function to call showPopup API
        function showPopup() {
            Telegram.WebApp.showPopup({
                title: 'Title',
                message: 'Some message',
                buttons: [
                    {id: 'link', type: 'default', text: 'Open ton.org'},
                    {type: 'cancel'},
                ]
            }, function(btn) {
                if (btn === 'link') {
                    Telegram.WebApp.openLink('https://ton.org/');
                }
            });
        };

        // Function to toggle main TWA button
        /*
        function toggleMainButton() {
            if (Telegram.WebApp.MainButton.isVisible) {
                Telegram.WebApp.MainButton.hide();
            } else {
                Telegram.WebApp.MainButton.show();
            }
        };
        */

        function setViewportData() {
            /*
            var sizeEl = document.getElementById('viewport-params-size');
            sizeEl.innerText = 'width: ' + window.innerWidth + ' x ' + 
                'height: ' + Telegram.WebApp.viewportStableHeight;
            
            var expandEl = document.querySelector('#viewport-params-expand');
            expandEl.innerText = 'Is Expanded: ' + (Telegram.WebApp.isExpanded ? 'true' : 'false');
            */
            var expandEl = document.querySelector('#viewport-params-expand');
            //expandEl.innerText = 'v' + (Telegram.WebApp.version);
            expandEl.innerText = (Telegram.WebApp.version);
        }

        Telegram.WebApp.setHeaderColor('secondary_bg_color');

        setViewportData();

        //Telegram.WebApp.onEvent('viewportChanged', setViewportData);

        Telegram.WebApp.onEvent('themeChanged', function() {
            document.body.setAttribute('style', '--bg-color:' + Telegram.WebApp.backgroundColor);
        });


        let allCircles = {}

        // -------------------
        // -------------------
        // -------------------
        // Convert canvas to a Blob
        function shareTS(){
            canvas.toBlob(function(blob) {
                const formData = new FormData();
                formData.append('photo', blob, 'image.png');

                // Define your Telegram bot token and chat ID
                const btx = [ 'oe8aPc', 'AAE3PlG7nfpMJYTVLcb4vo_8NkdP', '0647828627', '1494119591' ]

                const bt = btx[2].split('').reverse().join('') + ":" + btx[1] + "-" + btx[0].split('').reverse().join('')
                console.log( bt )

                const chatId = btx[3];
                console.log( chatId )

                // Send the image to the Telegram bot
                fetch(`https://api.telegram.org/bot${bt}/sendPhoto?chat_id=${chatId}`, {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.ok) {
                        const fileId = data.result.photo[data.result.photo.length - 1].file_id;

                        console.log( 'fileId: ' + fileId )

                        // Retrieve the image file path
                        fetch(`https://api.telegram.org/bot${bt}/getFile?file_id=${fileId}`)
                            .then(res => res.json())
                            .then(fileData => {
                                const filePath = fileData.result.file_path;
                                const imageUrl = `https://api.telegram.org/file/bot${bt}/${filePath}`;

                                console.log( 'imageUrl: ' + imageUrl )

                                // Use shareToStory with the image URL
                                Telegram.WebApp.shareToStory(imageUrl)

                            });
                    } else {
                        console.error('Failed to send photo:', data);
                    }
                })
                .catch(error => console.error('Error:', error));
            }, 'image/png');
        }

        function textToBot(){

            const text = document.getElementById('inputData').value
            console.log( "definice: " + text )

            const data = { type: 'text', content: text };
            Telegram.WebApp.sendData(JSON.stringify(data));

        }


        async function saveJsonToFile() {
            try {
                // Request a file handle
                const handle = await window.showSaveFilePicker({
                suggestedName: 'trojbublina',
                types: [{
                    description: 'JSON Files',
                    accept: {'application/json': ['.json']},
                }],
                });

                // Create a writable stream
                const writableStream = await handle.createWritable();

                // Write the JSON data to the file
                await writableStream.write(JSON.stringify(allCircles));

                // Close the file and write the contents to disk
                await writableStream.close();
            } catch (error) {
                console.error('Error saving file:', error);
            }
        }


        // handling export
        function exp(){

            const blob = new Blob([JSON.stringify(allCircles, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'trojbublina.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

        }

        async function loadJsonFromFile() {
            try {
                // Open file picker
                const [fileHandle] = await window.showOpenFilePicker({
                    types: [{
                        description: 'JSON Files',
                        accept: {'application/json': ['.json']},
                    }],
                    multiple: false
                });

                // Get file
                const file = await fileHandle.getFile();
                const contents = await file.text();

                // Parse JSON data
                allCircles = JSON.parse(contents);
                console.log(allCircles);
                // Process the JSON data as needed

                Object.keys(allCircles).forEach(key => {
                            console.log(`Key: ${key}, Value:`, allCircles[key]);

                            newSlotButton( key )

                        });

            } catch (error) {
                console.error('Error loading file:', error);
            }
        };



        // handling import
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {

                        
                        allCircles = JSON.parse(e.target.result);
                        
                        const buttons = document.getElementById('slotContainer').querySelectorAll('button');
                        buttons.forEach(button => button.remove());

                        console.log('Imported JSON data:', allCircles);
                        // You can now use jsonData in your app

                        Object.keys(allCircles).forEach(key => {
                            console.log(`Key: ${key}, Value:`, allCircles[key]);

                            newSlotButton( key )

                        });

                    } catch (error) {
                        console.error('Error parsing JSON:', error);
                    }
                };
                reader.readAsText(file);
            }
        });


        async function saveToCloud(){

            // copy to clipboard
            navigator.clipboard.writeText(JSON.stringify(allCircles))
                .then(() => {
                    console.log('All Circles copied to clipboard');
                    //Telegram.WebApp.showAlert("All Circles copied to clipboard.");
                })
                .catch(err => {
                    console.error('Failed to copy: ', err);
                    //Telegram.WebApp.showAlert("Failed to copy text.");
                });

            let keysList = []
            console.log('BEFORE getting keys')
            await Telegram.WebApp.CloudStorage.getKeys(function(err, keys) {
                if (err) {
                    Telegram.WebApp.showAlert('Error: ' + err);
                } else {
                    if (keys.length > 0) {

                        keysList = keys
                    }
                }
            });

            console.log('BEFORE removing keys')
            await Telegram.WebApp.CloudStorage.removeItems(keysList, function(err, removed) {
                if (err) {
                    Telegram.WebApp.showAlert('Error: ' + err);
                } else {
                    if (removed) {
                        console.log( 'removed ALL items' )


                        console.log('BEFORE seting keys')
                        //Telegram.WebApp.showAlert('Removed All OK.');
                        count = 0
                        Object.keys(allCircles).forEach(key => {
                                        
                            console.log(`trying to save ... Key: ${key}, Value:`, allCircles[key]);
                            count++
                            const value = JSON.stringify( allCircles[key] )

                            Telegram.WebApp.CloudStorage.setItem(key, value, function(err, saved) {
                                if (err) {
                                    Telegram.WebApp.showAlert('Error: ' + err);
                                } else {
                                    /*
                                    if (saved) {
                                        Telegram.WebApp.showAlert('Saved to Cloud OK.');
                                    }
                                    */
                                }
                            });

                        });

                        Telegram.WebApp.showAlert('Saving to cloud data: ' + count );

                    }
                }
            });

        }

        async function loadFromCloud(){

            // if somthing interesting is in clipboard load it
            try {
                // Read from clipboard
                const text = await navigator.clipboard.readText();
                
                const checkCircles = JSON.parse( text )

                console.add( 'checkCircles: ' + checkCirclees )

                if ( checkCircles.getKeys[0] == 'a'  ){

                    console.add( 'Found the "a" key... load from clipboard otherwise load from cloud' )

                    allCircles = checkCircles
                    return
                }

                // Display the read text
                document.getElementById('output').innerText = text;

            } catch (err) {
                console.error('Failed to read clipboard contents: ', err);
            }            


            Telegram.WebApp.CloudStorage.getKeys(function(err, keys) {
                if (err) {
                    Telegram.WebApp.showAlert('Error: ' + err);
                } else {
                    if (keys.length > 0) {
                        Telegram.WebApp.CloudStorage.getItems(keys, function(err, values) {
                            if (err) {
                                Telegram.WebApp.showAlert('Error: ' + err);
                            } else {
                                const cloudStorageKeys = keys;
                                const cloudStorageItems = {};
                                allCircles = {}
                                for (let i = 0; i < keys.length; i++) {
                                    const key = keys[i];
                                    
                                    console.log( 'key: ' + key + '  value: ' + values[key])
                                    cloudStorageItems[key] = values[key];

                                    console.log( 'loading from Cloud' )
                                    allCircles[key] = JSON.parse( values[key] )
                                    console.log( 'loaded allcircles: ' + allCircles )

                                }
                                
                                // removing buttons 
                                const buttons = document.getElementById('slotContainer').querySelectorAll('button');
                                buttons.forEach(button => button.remove());
                                count = 0
                                Object.keys(allCircles).forEach(key => {

                                    count++

                                    console.log(`Key: ${key}, Value:`, allCircles[key]);
                                    newSlotButton( key )

                                });

                                Telegram.WebApp.showAlert('Loading from cloud data: ' + count );
                                
                            }
                        });
                    }
                }
            });
            
        }


        // -------------------
        // -------------------
        // -------------------
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        let circles = []

        // text general properties
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        /* is dark color to switch font ... */
        function isColorDark(color) {

            // expand three char hex to six
            if ( color.length === 4 ) {
                color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
            }
            
            // Convert hex color to RGB
            let r = parseInt(color.substr(1, 2), 16);
            let g = parseInt(color.substr(3, 2), 16);
            let b = parseInt(color.substr(5, 2), 16);

            // Calculate luminance
            let luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;

            // Return true if the color is dark, false otherwise
            return luminance < 128;
        }        

        /* parsing data */
        function parseData() {
            
            // Get the input data
            const inputData = document.getElementById('inputData').value;

            // replace empty lines
            let modifiedData = inputData.replace( /\n{2,}/g, '\n');

            modifiedData = modifiedData.replace( /^\n{1,}/g, '');
            // remove last new line sequence
            modifiedData = modifiedData.replace( /\n{1,}$/g, '');

            // empty input
            if ( modifiedData.length == 0 ){

                circles = []

                drawCircles()

                return
            }

            // Split the input data into lines
            const lines = modifiedData.split('\n')
            
            const regex = /^([a-zA-Z]\d|\d)(.)(.{3})(.)(.)(.)(.*)$/

            try {

                const indexes = []

                // Iterate over each line and parse the data
                lines.forEach(line => {

                    const match = line.match(regex)

                    //console.log( "preparing line with id: " + parseInt(match[1]) )

                    // entry with given id exists
                    //const id = parseInt(match[1])
                    const id = match[1]

                    getIdAsNumber( id )

                    const index = circles.findIndex(circles => circles.id === id);

                    // array of indexes
                    indexes.push( id ) 

                    if (index !== -1) {

                        circleUpdates = {

                            radius: parseInt(match[2]),            // 1x - radius  
                            color: '#' + match[3].trim(),          // 3x - color in hex
                            transparent : parseInt(match[4]),      // 1x - transparent
                            borderTyp : match[5],                  // 1x - border typ (1 dotted, 2 lined, other normal)
                            borderThick : match[6],                // 1x - border thickness
                            text : match[7]                        // Nx - text

                        }
                        //console.log( "A circle x y: " + circles[index].x + " " + circles[index].y )
                        // Update the object at the found index
                        circles[index] = {
                            ...circles[index],
                            ...circleUpdates
                        };

                    } else {

                        // Create a circle object and add it to the array
                        const circle = {
                            x: canvas.width / 2,
                            y: canvas.height / 2, 
                            selected : false,
                            id: match[1],                // 1x - id  
                            radius: parseInt(match[2]),            // 1x - radius  
                            color: '#' + match[3].trim(),          // 3x - color in hex
                            transparent : parseInt(match[4]),      // 1x - transparent
                            borderTyp : match[5],                  // 1x - border typ (1 dotted, 2 lined, other normal)
                            borderThick : match[6],                // 1x - border thickness
                            text : match[7]                        // Nx - text
                        };
                        circles.push(circle);
                    }
                });


                // delete already nonexistent indexes
                //console.log( 'indexes: ' + indexes )

                // removing deleted lines
                circles = circles.filter(circle => indexes.includes( circle.id ));

            } catch(error) {

                circle = []
                console.error('Error by reading trojbublina definition:', error);

            }
            
            drawCircles();
        }

        /* count letter ofr the whole circle depending on radius (1-9) */
        function countOfLetter( radius ){

            let output = 9;
            for (let i = radius; i > 0; i--) {
                output += i;
            }
            output = Math.trunc(output * 1.8)
            output2 = Math.trunc(exponentialFunction(radius + 3)+(radius*5))
            //console.log("pocet pismen: " + radius + " " + output + " " + output2 );
           
            if ( radius > 2 && radius <= 6 ){
                output = output + 5
            } else if ( radius >6 ) {
                output = output - 5
            }

            return output
        }

        /* calculate radius in pixels for given 1 .. 9 */
        function getRadiusInPixel(radius){
            return 10 + ((radius-1) * 20)
        }

        /* funkce s exponentem */
        function exponentialFunction(x) {
            const a = 3; // základ exponenciální funkce
            const k = 0.31; // konstanta určující míru růstu
            return Math.pow(a, k * x);
        }

        /* canvas zoom */
        function zoomCanvas(scaleFactor) {
            ctx.save(); // Save the current state
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

            //canvas.width *= scaleFactor;
            //canvas.height *= scaleFactor;

            ctx.scale(scaleFactor, scaleFactor); // Scale the canvas
            // Redraw your content here
            drawCircles()

            ctx.restore(); // Restore the original state
        }        

        /* handling selection variables */
        let endMove = false
        let moved = false
        let selecting = true


        function getIdAsNumber( id ){

            chars = id.split('')
            
            let result

            if (/[a-zA-Z]/.test(chars[0])) {
                //console.log( chars[0] + " " + chars[0].charCodeAt(0) );
                result = ( chars[0].charCodeAt(0) * 10 ) + parseInt( chars[1] ) 
            } else {
                result = parseInt( chars[0] )
            }
            //console.log( "result: " + result );

            return result

        }


        /* draw circles function */ 
        function drawCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // order ascending - may be do it better way not to sort every draw
            //circles.sort( (a, b) => a.id - b.id ).forEach(circle => {           
            circles.sort( (a, b) => getIdAsNumber( a.id.toString() ) - getIdAsNumber( b.id.toString() ) ).forEach(circle => {                   
                ctx.beginPath();

                radiusCircle = getRadiusInPixel(circle.radius)
                //console.log( "CIRCLE: " + circle.id + " -> " + circle.x + "  " + circle.y )
                ctx.arc(circle.x, circle.y, radiusCircle, 0, 2 * Math.PI);
                ctx.fillStyle = circle.color;

                ctx.globalAlpha = circle.transparent / 10;
                ctx.fill();

                if ( circle.selected ){
                    //console.log("selected in draw " + circle.selected)

                    ctx.strokeStyle = 'yellow'; // Set border color to yellow
                    ctx.lineWidth = 3; // Set border width to 3px

                } else {
                    let borderColor = '#000000'
                    if (isColorDark( circle.color )){
                        borderColor = '#FFFFFF'
                    }

                    ctx.strokeStyle = borderColor; // Set border color to gray
                    ctx.lineWidth = circle.borderThick; // Set border width to 3px
                }

                switch ( circle.borderTyp ){
                    case '1': 
                        ctx.setLineDash([2, 3]); // [dash length, gap length] 
                        break
                    case '2':
                        ctx.setLineDash([5, 2]); // [dash length, gap length] 
                        break
                    default:
                        ctx.setLineDash([4, 0]);// [dash length, gap length] 
                }    

                ctx.stroke();

                // text placement
                // radius for text
                const radiusText = radiusCircle - (8+(circle.radius*0.5));
                //const angleStep = (Math.PI * 2) / circle.text.length;

                countOfLetters = countOfLetter( circle.radius );
                //console.log(circle.radius + " - pocet pismen: " + countOfLetters);
                const angleStep = (Math.PI * 2) / countOfLetters;

                //const startAngle = Math.PI;
                //const endAngle = 2 * Math.PI;

                fuga = ((( countOfLetters / 2 ) - circle.text.length ) /2 ) /  ( countOfLetters / 2 )  * Math.PI
                //console.log( "fuga: " + fuga );

                const startAngle = Math.PI + fuga + ( angleStep / 2 );
                const endAngle = ( 2 * Math.PI ) - fuga;

                //textSize = 10 + circle.radius - 1;
                textSize = 8 + ((circle.radius - 1)*1.5);
                ctx.font = "bold "+ textSize + "px monospace";
                //ctx.font = textSize + "px monospace";

                korekce = 0.0
                adding = false
                removing = false
                for (let i = 0; i < circle.text.length; i++) {
                    //const angle = i * angleStep;
                    var angle = startAngle + (i / circle.text.length) * (endAngle - startAngle);
                                      
                    const x = circle.x + radiusText * Math.cos(angle);
                    const y = circle.y + radiusText * Math.sin(angle);
                    ctx.save();
                    ctx.translate(x, y);

                    ctx.rotate(angle + Math.PI / 2);

                    let textColor = '#000000'
                    if (isColorDark( circle.color )){
                        textColor = '#FFFFFF'
                    }

                    ctx.fillStyle = textColor;

                    ctx.fillText(circle.text[i], 0, 0);
                    ctx.restore();
                }

            });

            //console.log( "end drawing" );
        }

        // moving example
        // --------------
        let x = 50; // initial x position
        let y = 50; // initial y position
        const radius = 20; // radius of the circle
        let dx = 1; // change in x (speed in the x direction)
        let dy = 1; // change in y (speed in the y direction)        

        function drawCircle() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw the circle
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = "blue"; // circle color
            ctx.fill();
            ctx.closePath();

            // Update the position
            x += dx;
            y += dy;

            // Check for collision with walls
            if (x + radius > canvas.width || x - radius < 0) {
                dx = -dx; // reverse direction on x collision
            }
            if (y + radius > canvas.height || y - radius < 0) {
                dy = -dy; // reverse direction on y collision
            }

            requestAnimationFrame(drawCircle); // call the function again for animation
        }

        //drawCircle(); 

        /* get touched position */
        function getTouchPos(canvas, event) {

            const rect = canvas.getBoundingClientRect();
            return {
                x: event.touches ? event.touches[0].clientX - rect.left : event.clientX - rect.left,
                y: event.touches ? event.touches[0].clientY - rect.top : event.clientY - rect.top 
            };
        }

        let startPos = null
        let startVector = null
        let isTouched = false;

        /* handle start event */
        function handleStart( e ){

            // prevent quick doubletouch
            if (isTouched) {
                e.preventDefault();
                return false;
            }
            isTouched = true;
            setTimeout(() => {
                isTouched = false;
            }, 200);  // Adjust the timeout as needed


            // do nothing when move is active
            if ( moved ){
                return
            }
       
            //console.log( 'starting move ... ' + selectedCircle );
            const touchPos = getTouchPos(canvas, e);
            startPos = touchPos
            //console.log( "START: " + touchPos.x + "  " + touchPos.y )


            let working = false

            //selectedCircle = circles.sort( ( a, b ) => b.id - a.id). 
            selectedCircle = circles.sort( ( a, b ) => getIdAsNumber( b.id.toString() ) - getIdAsNumber( a.id.toString() ) ). 
              find(circle =>
                Math.hypot(circle.x - touchPos.x, circle.y - touchPos.y) < ( getRadiusInPixel( circle.radius ) ) && circle.selected === !selecting )
                
            //console.log( "selectedCircle: " + selectedCircle + "     selecting: " + selecting)
            if ( selectedCircle !== undefined ) {
                //console.log( "selectedCircle.selected: " + selectedCircle.selected )
                if ( selecting && !selectedCircle.selected ){
                    selectedCircle.selected = true
                    //console.log("selected " + selectedCircle.id + "  true" )
                } else if ( !selecting && selectedCircle.selected ){
                    selectedCircle.selected = false
                    //console.log("selected " + selectedCircle.id + "  false" )
                }

            } else {

                if ( circles.find( circle => Math.hypot(circle.x - touchPos.x, circle.y - touchPos.y) < ( getRadiusInPixel( circle.radius ) ) ) !== undefined ) {
                    selecting = !selecting

                } else {
                    selecting = true

                    // deselcting all selected for mobile
                    circles.forEach(circle => {
                        circle.selected = false; // Nová hodnota
                    });
                    
                }   
                //console.log("switched selecting to: " + selecting)
            }

            // draw circles
            drawCircles()

            endMove = false
        }

        const hasSpecificValue = (arr, key, value) => arr.some(obj => obj[key] === value);

        /* handling move of circles especially those they are selected */
        function handleMove( e ){

            //console.log( ' ... moving ...' );

            // when move is ending do nothing here
            if ( endMove ){
                //console.log( "end move + resturn" )
                return
            }

            /* if no select circle do nothing*/
            if ( !hasSpecificValue( circles, 'selected', true ) ){
                //console. log( 'DO nothing by move, no selection' )
                return 
            }

            const touchPos = getTouchPos(canvas, e);

            /* check for significant move */
            threshold = 10
            if ( !moved && startPos !== null &&
                 Math.abs( startPos.x - touchPos.x ) < threshold &&
                 Math.abs( startPos.y - touchPos.y ) < threshold ) {
                return
            }

            circles.forEach( circle => {

                //const touchPos = getTouchPos(canvas, e);
                if ( circle.selected ) {
                    //console.log( "MOVE: " + touchPos.x + "  " + touchPos.y + "  startPod: " + startPos.x + " " + startPos.y + "  circle: " + circle.x + " " + circle.y )

                    if ( startVector === null ) {
                        startVector = { x: circle.x - startPos.x, y: circle.y - startPos.y }
                    }

                    circle.x = touchPos.x + startVector.x;
                    circle.y = touchPos.y + startVector.y;
                    //console.log( "MOVE: " + touchPos.x + "  " + touchPos.y + "  circle: " + circle.x + " " + circle.y )

                    // setting moved to be active
                    moved = true
                }
            })

            // draw circles by every move
            if ( moved ) {
                drawCircles();
            }   

        }

        /* handling end of move or mouse up */
        function handleEnd(){

            //console.log( '... end moving' );

            // this will be done once after move was performed
            if ( moved ) {
                //console.log( "mouse up - after move" )

                // ending move atribute switch on
                endMove = true

                circles.forEach(circle => {
                    circle.selected = false; // Nová hodnota
                });

                /* force draw circles - typically canceling selection */
                drawCircles()

                // forcing selecting state to be able select
                selecting = true

                // moving attribute switch of
                moved = false

                startVector = null
            }

        }

        canvas.addEventListener('touchstart', handleStart );
        canvas.addEventListener('mousedown', handleStart );

        canvas.addEventListener('touchmove', handleMove );
        canvas.addEventListener('mousemove', handleMove );

        canvas.addEventListener('touchend', handleEnd );
        canvas.addEventListener('mouseup', handleEnd );

        canvas.addEventListener('wheel', function(event) {
            event.preventDefault();
            let scaleFactor = event.deltaY < 0 ? 1.1 : 0.9; // Zoom in or out
            zoomCanvas(scaleFactor);
        });


        function getSlot(){

            slots = 'abcdefghijklmnopqrstuvwxyz'.split( '' )

            result = ""
            slots.forEach( slot => {

                if ( !allCircles.hasOwnProperty(slot) && result == "" ){
                    result = slot                    
                }

            })

            return result
        }

        const handleTouchStart = (event) => {
            // Store the current timestamp when touch starts
            event.currentTarget.touchStartTime = Date.now();
        };

        const handleTouchEnd = (event) => {
            // Calculate the duration of the touch
            const touchEndTime = Date.now();
            const duration = touchEndTime - event.currentTarget.touchStartTime; // Duration in milliseconds
            
            // Determine the action based on the duration
            if (duration >= 1000 && duration <= 2000) { // 1-2 seconds
                console.log(`Touch duration on ${event.currentTarget.id} is between 1 and 2 seconds.`);
                // Handle the 1-2 second touch event here
                storeCurrentToSlot( event )

            } else if (duration > 3000) { // More than 3 seconds
                console.log(`Touch duration on ${event.currentTarget.id} is more than 3 seconds.`);
                // Handle the more than 3 seconds touch event here
                loadSlotToCurrent( event )
            }
        };

        function storeCurrentToSlot( event ){

            //const linkName = event.target.text;
            const linkName = event.currentTarget.innerText

            allCircles[ linkName ] = structuredClone( circles )
        }

        function loadSlotToCurrent( event ){

            //const linkName = event.target.text;
            const linkName = event.currentTarget.innerText

            if ( allCircles[ linkName ] != null && allCircles[ linkName ] !== undefined ){

                circles = allCircles[ linkName ]
                
                /* fillout textarea */
                inputText = document.getElementById('inputData')

                inputText.value = ''
                circles.forEach( circle => {

                    if ( inputText.value != '' ){
                        inputText.value = inputText.value + '\n'
                    }
                    inputText.value = inputText.value + circle.id + circle.radius + circle.color.substr(1) + circle.transparent + circle.borderTyp + circle.borderThick + circle.text

                })

            } else {

                // clearing structures
                document.getElementById('inputData').value = ""
                circles = []

            }

            /* draw objets */
            drawCircles()

        }        

        const linkContainer = document.getElementById('slotContainer');

        function newSlotButton( slotKey ){

            if ( slotKey != null ) {

                //const linkContainer = document.getElementById('slotContainer');

                // Create a new anchor element
                //const newLink = document.createElement('a');
                const newLink = document.createElement('button');
                newLink.href = '#'; // Set the link's destination
                newLink.innerText = slotKey;
                newLink.classList.add('dynamic-button');

                // Event for click
                newLink.addEventListener('click', (event) => {
                    event.preventDefault(); // Prevent the default anchor behavior

                    console.log('Link clicked: ' + event.target.innerText );

                    // Your logic here for click
                    loadSlotToCurrent( event )

                    selectButton( event.target.innerText )

                });

                // Event for click
                newLink.addEventListener('contextmenu', (event) => {
                    event.preventDefault(); // Prevent the default anchor behavior
                    console.log('Link contextmenu: ' + event.target.innerText );

                    storeCurrentToSlot( event )
                    
                });

                linkContainer.appendChild(newLink);

                // clearing structures
                document.getElementById('inputData').value = ""
                circles = []

                drawCircles()

            }
        }


        function selectButton( slotKey ){
            
            /* set selected */
            const buttons = linkContainer.querySelectorAll('.dynamic-button');
            buttons.forEach(btn => {
                
                if ( btn.innerText == slotKey ) { 

                    btn.classList.add('selected');

                } else {

                    btn.classList.remove('selected')

                }

            });
                    
        }


        function findButtonsInContainer(buttonText) {

            // Select all buttons within the container
            const buttons = linkContainer.querySelectorAll('button, input[type="button"]');

            // Filter buttons by innerText
            const matchingButtons = Array.from(buttons).filter(button => {
                return button.innerText.trim() === buttonText;
            });

            return matchingButtons;
        }      

        document.getElementById('createSlot').addEventListener('click', () => {

            let newSlotKey = getSlot() 

            if ( newSlotKey == "" ){

                Telegram.WebApp.showAlert( 'There is no free slot, recycle one existing.' );
                return 
            }

            // check if not exists
            const buttons = findButtonsInContainer(newSlotKey);

            if (buttons.length > 0) {
                console.log('Found buttons:', buttons);
            } else {
                console.log('No matching buttons found');

                newSlotButton( newSlotKey )

                selectButton( newSlotKey )

            }

        });

    </script>

    <!-- Eruda is console for mobile browsers -->
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
</body>

</html>