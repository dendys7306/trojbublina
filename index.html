<!DOCTYPE html>
<html lang="en">

<head>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Touch Move</title>
    <style>
        canvas {
            border: 1px solid rgb(69, 69, 69);
        }
    </style>

</head>

<body>
    <div style="font-family: monospace; font-size: 16px; color: #696969;">
        19ABD511Pravda (hranice to/ne-to)<br/>
        2778A724Dobro (rozvoj společný)<br/>
        35498933Krása (individuální)
    </div>
    
    <textarea id="inputData" style="width: 360px; height: 150px; overflow: auto; font-family: monospace; font-size: 16px;" rows="7" cols="80" placeholder="17ABD932Pravda (hranice to/ne-to)"></textarea> 
    <button onclick="parseData()">přepočítat</button>
    <button onclick="alert('1x idéčko \n1x velikost (1-9)\n3x barva v hex (AB8)\n1x transparentnost (1-9)\n1x border type (1 ..., 2 --, other normal)\n1x border thickness (1-9)\ntext');">popis</button>
    <canvas id="myCanvas" width="360" height="400"></canvas>
    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        let circles = []

        // text general properties
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        /* is dark color to switch font ... */
        function isColorDark(color) {

            // expand three char hex to six
            if ( color.length === 4 ) {
                color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
            }
            
            // Convert hex color to RGB
            let r = parseInt(color.substr(1, 2), 16);
            let g = parseInt(color.substr(3, 2), 16);
            let b = parseInt(color.substr(5, 2), 16);

            // Calculate luminance
            let luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;

            // Return true if the color is dark, false otherwise
            return luminance < 128;
        }        

        /* parsing data */
        function parseData() {
            
            // Get the input data
            const inputData = document.getElementById('inputData').value;
            
            // Split the input data into lines
            const lines = inputData.split('\n');
            
            const regex = /^(.)(.)(.{3})(.)(.)(.)(.*)$/;

            // Iterate over each line and parse the data
            lines.forEach(line => {

                const match = line.match(regex);

                //console.log( "preparing line with id: " + parseInt(match[1]) )

                // entry with given id exists
                const index = circles.findIndex(circles => circles.id === parseInt(match[1]));

                if (index !== -1) {

                    circleUpdates = {

                        radius: parseInt(match[2]),            // 1x - radius  
                        color: '#' + match[3].trim(),          // 3x - color in hex
                        transparent : parseInt(match[4]),      // 1x - transparent
                        borderTyp : match[5],                  // 1x - border typ (1 dotted, 2 lined, other normal)
                        borderThick : match[6],                // 1x - border thickness
                        text : match[7]                        // Nx - text

                    }

                    // Update the object at the found index
                    circles[index] = {
                        ...circles[index],
                        ...circleUpdates
                    };

                } else {

                    // Create a circle object and add it to the array
                    const circle = {
                        x: canvas.width / 2,
                        y: canvas.height / 2, 
                        selected : false,
                        id: parseInt(match[1]),                // 1x - id  
                        radius: parseInt(match[2]),            // 1x - radius  
                        color: '#' + match[3].trim(),          // 3x - color in hex
                        transparent : parseInt(match[4]),      // 1x - transparent
                        borderTyp : match[5],                  // 1x - border typ (1 dotted, 2 lined, other normal)
                        borderThick : match[6],                // 1x - border thickness
                        text : match[7]                        // Nx - text
                    };
                    circles.push(circle);
                }
            });
            
            //console.log(circles);
            //circles.sort( (a,b) => a.id - b.id );
            //console.log(circles);

            drawCircles();
        }

        /* count letter ofr the whole circle depending on radius (1-9) */
        function countOfLetter( radius ){

            let output = 9;
            for (let i = radius; i > 0; i--) {
                output += i;
            }
            output = Math.trunc(output * 1.8)
            output2 = Math.trunc(exponentialFunction(radius + 3)+(radius*5))
            //console.log("pocet pismen: " + radius + " " + output + " " + output2 );
           
            if ( radius > 2 && radius <= 6 ){
                output = output + 5
            } else if ( radius >6 ) {
                output = output - 5
            }

            return output
        }

        /* calculate radius in pixels for given 1 .. 9 */
        function getRadiusInPixel(radius){
            return 10 + ((radius-1) * 20)
        }

        /* funkce s exponentem */
        function exponentialFunction(x) {
            const a = 3; // základ exponenciální funkce
            const k = 0.31; // konstanta určující míru růstu
            return Math.pow(a, k * x);
        }

        /* canvas zoom */
        function zoomCanvas(scaleFactor) {
            ctx.save(); // Save the current state
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

            //canvas.width *= scaleFactor;
            //canvas.height *= scaleFactor;

            ctx.scale(scaleFactor, scaleFactor); // Scale the canvas
            // Redraw your content here
            drawCircles()

            ctx.restore(); // Restore the original state
        }        

        /* handling selection variables */
        let endMove = false
        let moved = false
        let selecting = true

        /* draw circles function */ 
        function drawCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // order ascending - may be do it better way not to sort every draw
            circles.sort( (a, b) => a.id - b.id ).forEach(circle => {               
            //circles.forEach(circle => {               
                ctx.beginPath();

                radiusCircle = getRadiusInPixel(circle.radius)
                ctx.arc(circle.x, circle.y, radiusCircle, 0, 2 * Math.PI);
                ctx.fillStyle = circle.color;

                ctx.globalAlpha = circle.transparent / 10;
                ctx.fill();

                if ( circle.selected ){
                    //console.log("selected in draw " + circle.selected)

                    ctx.strokeStyle = 'yellow'; // Set border color to yellow
                    ctx.lineWidth = 3; // Set border width to 3px

                } else {
                    let borderColor = '#000000'
                    if (isColorDark( circle.color )){
                        borderColor = '#FFFFFF'
                    }

                    ctx.strokeStyle = borderColor; // Set border color to gray
                    ctx.lineWidth = circle.borderThick; // Set border width to 3px
                }

                switch ( circle.borderTyp ){
                    case '1': 
                        ctx.setLineDash([2, 3]); // [dash length, gap length] 
                        break
                    case '2':
                        ctx.setLineDash([5, 2]); // [dash length, gap length] 
                        break
                    default:
                        ctx.setLineDash([4, 0]);// [dash length, gap length] 
                }    

                ctx.stroke();

                // text placement
                // radius for text
                const radiusText = radiusCircle - (8+(circle.radius*0.5));
                //const angleStep = (Math.PI * 2) / circle.text.length;

                countOfLetters = countOfLetter( circle.radius );
                //console.log(circle.radius + " - pocet pismen: " + countOfLetters);
                const angleStep = (Math.PI * 2) / countOfLetters;

                //const startAngle = Math.PI;
                //const endAngle = 2 * Math.PI;

                fuga = ((( countOfLetters / 2 ) - circle.text.length ) /2 ) /  ( countOfLetters / 2 )  * Math.PI
                //console.log( "fuga: " + fuga );

                const startAngle = Math.PI + fuga + ( angleStep / 2 );
                const endAngle = ( 2 * Math.PI ) - fuga;

                //textSize = 10 + circle.radius - 1;
                textSize = 8 + ((circle.radius - 1)*1.5);
                ctx.font = "bold "+ textSize + "px Times";

                for (let i = 0; i < circle.text.length; i++) {
                    //const angle = i * angleStep;
                    var angle = startAngle + (i / circle.text.length) * (endAngle - startAngle);

                    const x = circle.x + radiusText * Math.cos(angle);
                    const y = circle.y + radiusText * Math.sin(angle);
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle + Math.PI / 2);

                    let textColor = '#000000'
                    if (isColorDark( circle.color )){
                        textColor = '#FFFFFF'
                    }

                    ctx.fillStyle = textColor;
                    //ctx.fillStyle = 'black';
                    ctx.fillText(circle.text[i], 0, 0);
                    ctx.restore();
                }

            });

            //console.log( "end drawing" );
        }

        /* get touched position */
        function getTouchPos(canvas, event) {

            const rect = canvas.getBoundingClientRect();
            return {
                x: event.touches ? event.touches[0].clientX - rect.left : event.clientX - rect.left,
                y: event.touches ? event.touches[0].clientY - rect.top : event.clientY - rect.top 
            };
        }

        /* handle start event */
        function handleStart( e ){

            // do nothing when move is active
            if ( moved ){
                return
            }
       
            //console.log( 'starting move ... ' + selectedCircle );
            const touchPos = getTouchPos(canvas, e);
            
            let working = false

            selectedCircle = circles.sort( ( a, b ) => b.id - a.id). 
              find(circle =>
                Math.hypot(circle.x - touchPos.x, circle.y - touchPos.y) < ( getRadiusInPixel( circle.radius ) ) && circle.selected === !selecting )
                
            //console.log( "selectedCircle: " + selectedCircle + "     selecting: " + selecting)
            if ( selectedCircle !== undefined ) {
                //console.log( "selectedCircle.selected: " + selectedCircle.selected )
                if ( selecting && !selectedCircle.selected ){
                    selectedCircle.selected = true
                    //console.log("selected " + selectedCircle.id + "  true" )
                } else if ( !selecting && selectedCircle.selected ){
                    selectedCircle.selected = false
                    //console.log("selected " + selectedCircle.id + "  false" )
                }

            } else {

                if ( circles.find( circle => Math.hypot(circle.x - touchPos.x, circle.y - touchPos.y) < ( getRadiusInPixel( circle.radius ) ) ) !== undefined ) {
                    selecting = !selecting
                } else {
                    selecting = true
                }   
                //console.log("switched selecting to: " + selecting)
            }

            // draw circles
            drawCircles()

            // 
            endMove = false
        }

        /* handling move of circles especially those they are selected */
        function handleMove( e ){

            //console.log( ' ... moving ...' );

            // when move is ending do nothing here
            if ( endMove ){
                //console.log( "end move + resturn" )
                return
            }

            const touchPos = getTouchPos(canvas, e);

            circles.forEach( circle => {

                //const touchPos = getTouchPos(canvas, e);
                if ( circle.selected ) {
                    circle.x = touchPos.x;
                    circle.y = touchPos.y;

                    // setting moved to be active
                    moved = true
                }
            })

            // draw circles by every move
            drawCircles();   

        }

        /* handling end of move or mouse up */
        function handleEnd(){

            //console.log( '... end moving' );

            // this will be done once after move was performed
            if ( moved ) {
                //console.log( "mouse up - after move" )

                // ending move atribute switch on
                endMove = true

                circles.forEach(circle => {
                    circle.selected = false; // Nová hodnota
                });

                /* force draw circles - typically canceling selection */
                drawCircles()

                // forcing selecting state to be able select
                selecting = true

                // moving attribute switch of
                moved = false
            }

            //drawCircles()

        }

        canvas.addEventListener('touchstart', handleStart );
        canvas.addEventListener('mousedown', handleStart );

        canvas.addEventListener('touchmove', handleMove );
        canvas.addEventListener('mousemove', handleMove );

        canvas.addEventListener('touchend', handleEnd );
        canvas.addEventListener('mouseup', handleEnd );

        canvas.addEventListener('wheel', function(event) {
            event.preventDefault();
            let scaleFactor = event.deltaY < 0 ? 1.1 : 0.9; // Zoom in or out
            zoomCanvas(scaleFactor);
        });

    </script>
</body>

</html>
